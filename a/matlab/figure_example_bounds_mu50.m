%%%%%%%%%%%%%%%%%% PANEL B OF FIGURE 3 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% (panel A of Figure 3 is the unrestricted age 35 graph, generated by gen_all_mob_plots)
% generate upper and lower p15 bounds on Age 35 graph

% Shows age 35 moments, plus two functions that fit it at reasonably high and low p25 values
%input_csv = '~/iecmerge/paul/mobility/data/age_35.csv';
input_csv =  '~/iec/output/mobility/moments/all_1960.csv';
graph_fn =   '/scratch/pn/fig_example_bounds_1960_mu50';
output_csv = '/scratch/pn/fig_example_bounds_1960_mu50.csv';
f2_limit = 100;
p_skip = 1;

% return value: matrix with p value, lower bound, upper bound
global A_moments b_moments f_min_mse

% possibly unnecessary definition of global MSE minimum
f_min_mse = 0;

% expand function evaluations for solver to give it a better chance to find the solution
options = optimoptions(@fmincon,'MaxFunEvals',1000000,'Display','none','TolCon',1e-3,'TolFun',1e-3,'TolX',1e-8);

% read bin means and values and convert to a set of bin cuts and values
[cuts, vals] = read_bins(input_csv);

% define number of p-values (i.e. p1 -> p100)
num_ps = 100;

% generate matrix -- used internally by inequality constraint function
[A_moments, b_moments] = get_moment_constraints(cuts, vals);

num_bounds = size(cuts, 2);

% create the numerical 2nd derivative matrix, which looks like this with 10 p-levels
e = eye(num_ps);
A_f2 = e(1:(num_ps-2), :) + [zeros((num_ps - 2), 2) eye(num_ps - 2)] + [zeros((num_ps - 2), 1) -2*eye(num_ps - 2)  zeros((num_ps - 2),1)];

% put positive and negative A_f2 in same matrix so we can use them with a single inequality constraint
A_f2_sym = [A_f2; -A_f2];

% set b_f2 limit -- multiply by 2 since needs to line up with both positive and negative A_f2 matrix
b_f2_sym = f2_limit * ones(2 * (num_ps - 2), 1);

% define monotonicity inequality constraint (9 inequality constraints if p1->p10)
A_pos_slope = e(1:(num_ps - 1), :) + [zeros((num_ps - 1), 1) -eye(num_ps - 1)];
b_pos_slope = zeros(num_ps - 1, 1);

% stack the inequality constraints that we want to use
A_ineq = [A_pos_slope; A_f2_sym];
b_ineq = [b_pos_slope; b_f2_sym];

% define starting points for optimizer -- perfect mobility and zero mobility
x0_perfect = 50 * ones(1, num_ps);

% set upper and lower bound vectors
lb = zeros(1, num_ps);
ub = 100 * ones(1, num_ps);

% create arrays to hold max and minimum values of p. start at extreme values, so we can tell if the solver failed
clear p_min p_max
p_min = zeros(1, num_ps);
p_max = ones(1, num_ps);
    
% STEP 1: CALCULATE MINIMUM MSE UNDER THIS f2 CONSTRAINT
fprintf('Calculating minimum MSE...\n');
[x_start, f_min_mse, exit_flag, output] = fmincon(@fun_mse, x0_perfect, [A_pos_slope; A_f2_sym], [b_pos_slope; b_f2_sym], [], [], lb, ub, [], options);
assert(exit_flag == 1 | exit_flag == 2);
    
% STEP 2: Generate two different solutions that get this MSE

% create inequality constraint vector: positive slope, f2 below threshold, MSE below threshold
A_ineq = [A_pos_slope; A_f2_sym];
b_ineq = [b_pos_slope; b_f2_sym];

% calculate max feasible p-level at one point in the graph
fun_mu50 = @(x) mean(x(1:50));
fun_minus_mu50 = @(x) -mean(x(1:50));

fprintf('Calculating bounds on mu50...\n');

% calculate maximum feasible p-level
[x_min, f_min, exit_flag, output] = fmincon(fun_mu50, x_start, A_ineq, b_ineq, [], [], lb, ub, @c_fun_mse, options);

% calculate minimum feasible p-level
[x_max, f_min, exit_flag, output] = fmincon(fun_minus_mu50, x_start, A_ineq, b_ineq, [], [], lb, ub, @c_fun_mse, options);

% plot upper and lower bounds 
fprintf('Printing Figure...\n')
plot_mob_bg(graph_fn, cuts, vals);

% plot them
plot_file(graph_fn, x_min);
plot_file(graph_fn, x_max);

